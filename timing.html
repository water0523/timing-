<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>timing计时器</title>
    <style>
        /* --- 全局样式 & 重置 --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden; /* 禁止整体滚动 */
            background-color: #fff;
            color: #333;
        }

        /* --- 场景容器 --- */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: none;
            flex-direction: column;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .screen.active {
            display: flex;
            opacity: 1;
            z-index: 10;
        }

        /* ==============================
           场景 1: 设置页面 (复刻图2、图4风格)
           ============================== */
        #setup-screen {
            background: #fff;
            padding: 24px;
            position: relative;
        }

        /* 标题部分 */
        .section-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-top: 20px;
            margin-bottom: 15px;
        }

        /* 输入框样式 */
        .input-group {
            margin-bottom: 40px;
        }

        .clean-input {
            width: 100%;
            padding: 10px 0;
            font-size: 18px;
            border: none;
            border-bottom: 1px solid #eee;
            outline: none;
            color: #555;
            background: transparent;
            border-radius: 0;
        }
        .clean-input::placeholder { color: #ccc; }

       /* --- CSS 修改部分 --- */

        /* 外层容器：负责左右布局，去掉了原来的 border-bottom */
        .duration-trigger-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding-bottom: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        /* 左侧提示文字 */
        .hint-text {
            font-size: 14px;
            color: #ccc; /* 默认灰色，设置后变金/橙色 */
            margin-bottom: 5px; /*为了和右边对齐 */
        }

/* 找到这一块，修改为： */
        .time-value-wrapper {
            /* 删掉或者注释掉下面这一行，默认不显示横线 */
            /* border-bottom: 2px solid #2196F3; */ 
            
            padding-bottom: 5px;
            min-width: 60px;
            text-align: right;
        }

        /* 数值文字样式 */
        .duration-display {
            font-size: 24px;
            font-weight: bold;
            color: #2196F3;
        }
        
        /* 单位（小时）样式 */
        .duration-unit {
            font-size: 16px;
            color: #333;
            margin-left: 5px;
            font-weight: normal;
        }

        /* 底部开始按钮 */
        .start-btn-container {
            position: absolute;
            bottom: 0; left: 0;
            width: 100%;
        }
        .start-btn {
            width: 100%;
            padding: 20px;
            background: #2196F3;
            color: white;
            font-size: 20px;
            border: none;
            font-weight: bold;
            cursor: pointer;
        }
        .start-btn:active { background: #1976D2; }

        /* ==============================
           弹窗: iOS 时间选择器 (复刻图3)
           ============================== */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.4);
            z-index: 50;
            visibility: hidden;
            opacity: 0;
            transition: all 0.3s;
        }
        .modal-overlay.open {
            visibility: visible;
            opacity: 1;
        }

        .picker-modal {
            position: fixed;
            bottom: 0; left: 0;
            width: 100%;
            background: #f2f2f2;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            z-index: 51;
            padding-bottom: 20px;
        }
        .picker-modal.open {
            transform: translateY(0);
        }

        /* 弹窗顶部工具栏 */
        .picker-toolbar {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }
        .toolbar-btn {
            font-size: 16px;
            border: none;
            background: none;
            cursor: pointer;
        }
        .btn-cancel { color: #888; }
        .btn-confirm { color: #2196F3; font-weight: bold; font-size: 18px; }

        /* 选择器容器 */
        .ios-picker-wrapper {
            position: relative;
            width: 100%;
            height: 240px;
            display: flex;
            justify-content: center;
            overflow: hidden;
            background: #f2f2f2;
            /* 渐变遮罩 */
            mask-image: linear-gradient(to bottom, transparent, black 40%, black 60%, transparent);
            -webkit-mask-image: linear-gradient(to bottom, transparent 5%, black 40%, black 60%, transparent 95%);
        }

        /* 高亮条 */
        .picker-highlight {
            position: absolute;
            top: 50%; left: 0;
            width: 100%; height: 44px;
            margin-top: -22px;
            background: rgba(255,255,255,0.7);
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            pointer-events: none;
            z-index: 0;
        }

/* --- 找到这个类，修改如下 --- */
        .picker-column {
            flex: 1;
            max-width: 100px;
            height: 100%;
            overflow-y: scroll;
            scrollbar-width: none;
            scroll-snap-type: y mandatory; /* 这是滚轮和原生滚动的吸附 */
            padding: 0;
            position: relative;
            z-index: 1;
            text-align: center;
            
            /* === 新增部分开始 === */
            cursor: grab;       /* 鼠标放上去显示抓取手势 */
            user-select: none;  /* 禁止拖拽时选中文本 */
            /* === 新增部分结束 === */
        }

        .picker-column::-webkit-scrollbar { display: none; }
        
        /* === 新增：按下时显示“紧抓”手势 === */
        .picker-column:active {
            cursor: grabbing;
        }

        .picker-item {
            height: 44px; /* 对应 highlight 高度 */
            line-height: 44px;
            font-size: 22px;
            color: #999;
            scroll-snap-align: center;
            transition: all 0.2s;
        }
        .picker-placeholder { height: 98px; } /* (240 - 44)/2 */

        .picker-label-text {
            line-height: 240px; /* 垂直居中 */
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin: 0 10px;
            z-index: 2;
        }

        /* ==============================
           场景 2: 计时器页面 (全屏沉浸)
           ============================== */
        #timer-screen {
            justify-content: center;
            align-items: center;
            color: white;
            background: #000; /* 默认黑底，防止图片加载前的白屏 */
        }

        /* 找到 .bg-layer，替换为以下代码 */
        .bg-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            
            /* 关键点1：图片放大到 120%，这样左右才有空间移动 */
            background-size: 120% 120%; 
            background-position: center;
            z-index: 0;
            opacity: 0.8;
            transition: background-image 1s ease-in-out;
            
            /* 关键点2：时长设为 20s，配合 alternate (往返) 
               去程 20s + 回程 20s = 40s 一个循环 */
            animation: moveBg 20s linear infinite alternate;
        }

        /* 找到 @keyframes moveBg，替换为以下代码 */
        @keyframes moveBg {
            0% { 
                /* 最左侧：图片的左边缘对齐屏幕左边缘 */
                background-position: 0% 50%; 
            }
            100% { 
                /* 最右侧：图片的右边缘对齐屏幕右边缘 */
                background-position: 100% 50%; 
            }
        }

        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3);
            z-index: 1;
        }

        /* 进度环容器 */
        .timer-circle {
            position: relative;
            width: 300px; height: 300px;
            z-index: 5;
        }
        svg { transform: rotate(-90deg); width: 100%; height: 100%; }
        circle { fill: none; stroke-width: 5; stroke-linecap: round; }
        .circle-bg { stroke: rgba(255,255,255,0.2); }
        .circle-progress { 
            stroke: #fff; 
            /* transition: stroke-dashoffset 0.1s linear;  <-- 务必删掉或注释掉这一行 */
        }

/* --- 核心容器：填满整个圆盘，不再依赖 translate 居中 --- */
        .timer-content {
            position: absolute;
            top: 0; left: 0;
            width: 100%; 
            height: 100%; /* 填满父容器(300x300) */
            
            display: flex;
            flex-direction: column; 
            align-items: center;
            justify-content: center; /* 内部内容居中 */
            
            /* 只做旋转，不移动位置，根除抖动源 */
            transform: perspective(600px) rotateY(0deg);
            transform-style: preserve-3d;
            backface-visibility: hidden;
            
            /* 动画设置 */
            transition: transform 0.5s linear, opacity 0.1s linear; 
            
            /* 硬件加速 */
            will-change: transform, opacity;
        }

        /* === 默认状态（图2）：时间在上，任务在下 === */
        
/* === 默认状态（图2）：时间是大字，文案是小字 === */
        
        .main-time {
            /* 默认顺序：1 */
            order: 1;
            
            font-size: 64px;
            /* 【修改点1】加粗：从 200 改为 400 (normal) */
            font-weight: 350; 
            letter-spacing: 2px;
            line-height: 1.2;
            /* 【修改点2】不透明度：拉满到 1 */
            color: rgba(255, 255, 255, 1); 
            margin: 0;
            transition: font-size 0.1s;
            /* 增加一点文字阴影增强清晰度 */
            text-shadow: 0 2px 4px rgba(0,0,0,0.1); 
        }

/* 任务名（在容器内部） */
.task-name-display {
    order: 2;
    font-size: 20px;
    font-weight: 500;
    margin-top: 5px;
    letter-spacing: 1px;
    color: rgba(255,255,255,0.9);
    
    transition: opacity 1.5s ease-in-out, font-size 0.1s; 
    opacity: 1;

    /* === 新增：单行省略号核心代码 === */
    white-space: nowrap;       /* 强制不换行 */
    overflow: hidden;          /* 超出部分隐藏 */
    text-overflow: ellipsis;   /* 超出部分显示 ... */
    max-width: 80%;            /* 限制最大宽度为圆圈的 80%，防止贴边 */
    text-align: center;        /* 短文本居中 */
    display: block;            /* 确保宽度生效 */
}
/* 新增：任务名的隐藏状态 */
.task-name-display.hidden {
    opacity: 0;
}

        /* === 初始模式（图1）：任务是大字，时间是小字 === */
        
        .timer-content.initial-mode .main-time {
            order: 2; /* 跑到下面 */
            
            font-size: 20px;
            font-weight: 350; /* 保持一致的字重，或者稍微细一点 */
            letter-spacing: 1px;
            opacity: 0.9;
            margin-top: 10px;
        }

        .timer-content.initial-mode .task-name-display {
            order: 1; /* 跑到上面 */
            
            font-size: 56px;
            /* 【修改点3】加粗：从 200 改为 400 */
            font-weight: 350; 
            margin-bottom: 0;
            margin-top: 0;
            /* 【修改点4】不透明度：拉满到 1 */
            opacity: 1;
            color: rgba(255, 255, 255, 1);
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* 翻转时的辅助类：只旋转，不位移 */
        .timer-content.rotate-out {
            transform: perspective(600px) rotateY(90deg);
        }

        /* 底部文字与按钮 */
        .text-area {
            position: absolute;
            bottom: 140px;
            width: 80%;
            text-align: center;
            z-index: 5;
            min-height: 50px;
        }
        /* 底部名言容器 */
/* 找到 .fade-text，替换为以下代码 */
.fade-text {
    font-size: 16px;
    line-height: 1.6;
    color: rgba(255,255,255,0.9);
    
    /* 关键：与任务名完全一致的过渡参数 */
    transition: opacity 1.5s ease-in-out;
    opacity: 1;
}
.fade-text.hidden { opacity: 0; }

        /* --- 底部按钮控制区 --- */
        .controls {
            position: absolute;
            bottom: 80px; /* 稍微往上提一点，留出空间 */
            z-index: 5;
            display: flex;
            gap: 40px; /* 两个按钮之间的间距 */
            justify-content: center;
            width: 100%;
        }

        /* 按钮通用基础样式 */
        .control-btn {
            padding: 12px 40px;    /* 增加左右内边距，使其呈长胶囊状 */
            border-radius: 50px;   /* 大圆角 */
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            outline: none;
            letter-spacing: 1px;   /* 字间距稍微拉开一点好看 */
        }

        /* 点击时的按压效果 */
        .control-btn:active {
            transform: scale(0.95);
        }

        /* === 左侧“结束”按钮样式 (白色填充) === */
        .btn-end {
            background-color: #ffffff;
            color: #333333;       /* 深灰色文字 */
            border: 1px solid #ffffff; /* 保持边框一致防止抖动 */
        }

        /* === 右侧“暂停”按钮样式 (透明描边) === */
        .btn-pause {
            background-color: transparent; /* 透明背景 */
            color: #ffffff;                /* 白色文字 */
            border: 1px solid rgba(255, 255, 255, 0.8); /* 半透明白边框 */
        }

        /* --- 历史记录下拉菜单样式 --- */
        .input-wrapper {
            position: relative; /* 确保下拉菜单相对于输入框定位 */
        }

        .history-dropdown {
            position: absolute;
            top: 100%; /* 在输入框正下方 */
            left: 0;
            width: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin-top: 10px;
            padding: 5px 0;
            z-index: 100;
            display: none; /* 默认隐藏 */
            border: 1px solid #eee;
        }

        /* 小三角箭头 */
        .history-dropdown::before {
            content: "";
            position: absolute;
            top: -6px;
            left: 20px;
            width: 12px;
            height: 12px;
            background: white;
            transform: rotate(45deg);
            border-top: 1px solid #eee;
            border-left: 1px solid #eee;
        }

        .history-item {
            padding: 12px 20px;
            font-size: 16px;
            color: #333;
            cursor: pointer;
            transition: background 0.2s;
        }

        .history-item:hover {
            background-color: #f5f5f5;
            color: #2196F3;
        }

/* --- 开发者模式控件样式 (修改版：顶部悬浮) --- */
.dev-controls {
    position: absolute;
    /* 改为顶部定位 */
    top: 60px;  /* 留出 60px 距离，避开手机刘海或状态栏 */
    left: 50%;  /* 水平居中起始点 */
    transform: translateX(-50%); /* 修正水平居中 */
    
    width: 90%;
    z-index: 100; /* 最高的层级，保证能点到 */
    
    text-align: center;
    background: rgba(0, 0, 0, 0.6); /*稍微加深一点背景，保证在亮色天空背景下也能看清*/
    padding: 12px;
    border-radius: 12px;
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3); /* 加一点阴影更有悬浮感 */
    
    /* 默认隐藏 */
    display: none; 
}

/* 里面的其他样式 (.dev-header, .dev-label 等) 不需要动，保持原样即可 */

/* --- 新增样式，放在 .dev-controls 后面 --- */

.dev-header {
    display: flex;
    justify-content: space-between; /* 两端对齐 */
    align-items: center;
    margin-bottom: 8px;
}

/* 覆盖之前的 .dev-label 样式，去掉 margin-bottom 因为父级控制了 */
.dev-label {
    color: #00ff00;
    font-size: 12px;
    font-family: monospace;
    text-align: left;
    margin: 0;
}

/* 关闭按钮样式 */
.dev-close {
    color: #ff4444; /* 警示红 */
    font-size: 24px;
    line-height: 1;
    cursor: pointer;
    font-weight: bold;
    padding: 0 5px;
    user-select: none;
}
.dev-close:hover {
    color: #ff0000;
    transform: scale(1.2);
}

.dev-label {
    color: #00ff00; /* 骇客绿，体现开发者模式 */
    font-size: 12px;
    margin-bottom: 5px;
    font-family: monospace;
    text-align: left;
}

#dev-slider {
    width: 100%;
    cursor: pointer;
    accent-color: #00ff00; /* 滑块颜色 */
}

/* --- 通用居中弹窗样式 --- */
.center-modal {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%) scale(0.9);
    background: white;
    width: 85%;
    max-width: 400px;
    border-radius: 16px;
    padding: 24px;
    z-index: 200;
    opacity: 0;
    visibility: hidden;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}
.center-modal.active {
    opacity: 1;
    visibility: visible;
    transform: translate(-50%, -50%) scale(1);
}
.wide-modal { max-width: 600px; }

.modal-title { font-size: 20px; font-weight: bold; margin-bottom: 10px; color: #333; }
.modal-info { font-size: 16px; color: #666; margin-bottom: 20px; }

.modal-header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
.close-icon { font-size: 24px; cursor: pointer; color: #999; padding: 5px; }

/* 文本域 */
.clean-textarea {
    width: 100%;
    height: 100px;
    padding: 10px;
    border: 1px solid #eee;
    background: #f9f9f9;
    border-radius: 8px;
    resize: none;
    font-family: inherit;
    font-size: 14px;
    outline: none;
}
.clean-textarea:focus { border-color: #2196F3; background: #fff; }

/* 按钮组 */
.modal-btns { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; }
.btn-cancel-flat { background: #f5f5f5; color: #666; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; }
.btn-confirm-flat { background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; }
.full-width { width: 100%; }

/* 历史列表 */
.history-list-container {
    max-height: 300px;
    overflow-y: auto;
    margin-bottom: 15px;
    border-top: 1px solid #eee;
}
.history-row {
    padding: 12px 0;
    border-bottom: 1px solid #eee;
    font-size: 14px;
}
.history-row-top { display: flex; justify-content: space-between; margin-bottom: 4px; font-weight: bold; color: #333; }
.history-row-mid { display: flex; justify-content: space-between; color: #888; font-size: 12px; }
.history-note { margin-top: 6px; background: #f0f8ff; padding: 6px; border-radius: 4px; color: #555; font-size: 13px; }
.empty-tip { text-align: center; padding: 30px; color: #999; }

/* --- 优化：删除按钮样式 --- */

/* 1. 专注历史列表的删除按钮 */
.history-row {
    position: relative; /* 为了定位删除按钮 */
    padding-right: 30px; /* 留出右边空间给删除按钮 */
}
.btn-delete-record {
    position: absolute;
    top: 12px;
    right: 5px;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    color: #ccc;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    border-radius: 50%;
    transition: all 0.2s;
}
.btn-delete-record:hover {
    background: #ffebee; /* 浅红背景 */
    color: #f44336;      /* 红色文字 */
}

/* 2. 输入框下拉菜单的布局优化 */
.history-item {
    display: flex; /* 改为弹性布局 */
    justify-content: space-between; /* 两端对齐 */
    align-items: center;
    padding: 0; /* 清除原有 padding，改在内部元素上 */
}

/* 左侧文字区域：占满剩余空间，可点击 */
.history-item-text {
    flex: 1; 
    padding: 12px 20px;
    cursor: pointer;
}
.history-item-text:hover {
    color: #2196F3; /* 保持原有的悬停变色 */
}

/* 右侧删除按钮 */
.history-item-del {
    padding: 12px 15px;
    color: #ddd;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
}
.history-item-del:hover {
    color: #f44336; /* 悬停变红 */
    background: #fafafa;
}
    </style>
</head>
<body>

    <!-- ================= 场景 1: 设置页面 ================= -->
    <div id="setup-screen" class="screen active">
        
        <div class="input-group">
            <div class="section-title">本次学习内容</div>
            
            <!-- 新增了一个 relative 定位的包裹层 -->
            <div class="input-wrapper">
                <!-- 注意：加了 autocomplete="off" 防止浏览器自带的历史记录遮挡 -->
                <input type="text" id="task-input" class="clean-input" value="" placeholder="如：背单词..." autocomplete="off">
                
                <!-- 历史记录下拉菜单 -->
                <div id="history-dropdown" class="history-dropdown">
                    <!-- JS 会自动填充内容 -->
                </div>
            </div>
        </div>

        <!-- HTML 修改部分 -->
        <div class="input-group">
            <div class="section-title">设置学习时长</div>
            
            <!-- 点击触发弹窗 -->
            <div class="duration-trigger-row" onclick="openPicker()">
                <!-- 左侧：提示语 -->
                <div class="hint-text" id="end-time-hint">到时会提醒学习结束</div>
                
                <!-- 右侧：数值 + 下划线 -->
                <div class="time-value-wrapper">
                    <!-- 初始显示“未设置”，单位隐藏 -->
                    <span class="duration-display" id="display-hours">未设置</span>
                    <span class="duration-unit" id="display-unit" style="display:none;">小时</span>
                </div>
            </div>
        </div>

        <div style="text-align: center; margin-bottom: 20px; margin-top: 10px;">
    <span onclick="openHistoryModal()" style="color: #2196F3; cursor: pointer; font-size: 14px; text-decoration: underline;">
        查看历史记录
    </span>
        </div>
        <!-- 底部开始按钮 -->
        <div class="start-btn-container">
            <button class="start-btn" onclick="startFocus()">开始学习</button>
        </div>
    </div>

    <!-- ================= 弹窗: 时间选择器 ================= -->
    <div class="modal-overlay" id="modal-overlay" onclick="closePicker()"></div>
    <div class="picker-modal" id="picker-modal">
        <!-- 顶部工具栏 -->
        <div class="picker-toolbar">
            <button class="toolbar-btn btn-cancel" onclick="closePicker()">取消</button>
            <button class="toolbar-btn btn-confirm" onclick="confirmPicker()">完成</button>
        </div>
        
        <!-- 滚轮主体 -->
        <div class="ios-picker-wrapper">
            <div class="picker-highlight"></div>

            <!-- 小时列 -->
            <div class="picker-column" id="col-hour">
                <div class="picker-content" id="hour-content"></div>
            </div>
            <div class="picker-label-text">小时</div>

            <!-- 分钟列 -->
            <div class="picker-column" id="col-minute">
                <div class="picker-content" id="minute-content"></div>
            </div>
            <div class="picker-label-text">分钟</div>
        </div>
    </div>


    <!-- ================= 场景 2: 计时器页面 ================= -->
    <div id="timer-screen" class="screen">
        <div class="bg-layer" id="bg-layer"></div>
        <div class="overlay"></div>

        <div class="timer-circle">
            <svg viewBox="0 0 300 300">
                <circle class="circle-bg" cx="150" cy="150" r="140"></circle>
                <circle class="circle-progress" id="progress-ring" cx="150" cy="150" r="140"></circle>
            </svg>
            <div class="timer-content">
                <div class="main-time" id="timer-display">00:00:00</div>
                <div class="task-name-display" id="timer-task-name"></div>
            </div>
        </div>

        <div class="text-area">
            <div id="alternating-text" class="fade-text"></div>
        </div>
        <!-- 开发者模式时间轴 (默认隐藏) -->
<!-- 找到之前的 dev-timeline-container，替换为以下代码 -->
<div id="dev-timeline-container" class="dev-controls" style="display: none;">
    <!-- 顶部栏：左边是文字，右边是关闭按钮 -->
    <div class="dev-header">
        <div class="dev-label">water不是水 (欣赏模式)</div>
        <div class="dev-close" onclick="exitDevMode()">×</div>
    </div>
    
    <input type="range" id="dev-slider" min="0" max="28800" step="1" value="0">
</div>
        <div class="controls">
            <!-- 结束按钮：加了 btn-end 类 -->
            <button class="control-btn btn-end" onclick="confirmEnd()">结束</button>
            
            <!-- 暂停按钮：加了 btn-pause 类 -->
            <button class="control-btn btn-pause" id="pause-btn" onclick="togglePause()">暂停</button>
        </div>
    </div>

    <!-- ================= 弹窗: 结束总结 (写备注) ================= -->
<div class="modal-overlay" id="summary-overlay"></div>
<div class="center-modal" id="summary-modal">
    <div class="modal-title">本次专注已结束</div>
    <div class="modal-info">时长：<span id="summary-duration">00:00:00</span></div>
    
    <div class="input-group" style="margin-bottom: 15px;">
        <textarea id="summary-note" class="clean-textarea" placeholder="记录一下刚才的收获或想法..."></textarea>
    </div>

    <div class="modal-btns">
        <button class="btn-cancel-flat" onclick="closeSummary(false)">不保存</button>
        <button class="btn-confirm-flat" onclick="saveAndExit()">保存记录</button>
    </div>
</div>

<!-- ================= 弹窗: 历史记录列表 ================= -->
<div class="modal-overlay" id="history-overlay" onclick="closeHistoryModal()"></div>
<div class="center-modal wide-modal" id="history-modal">
    <div class="modal-header-row">
        <div class="modal-title">专注历史</div>
        <div class="close-icon" onclick="closeHistoryModal()">×</div>
    </div>

    <div class="history-list-container" id="history-list-content">
        <!-- JS 动态填充 -->
    </div>

    <div class="modal-btns">
        <button class="btn-confirm-flat full-width" onclick="exportToExcel()">导出为 Excel</button>
    </div>
</div>
    <script>
        // ================= 配置数据 =================
// ================= 配置数据 (本地图片版) =================
const resources = [
            // --- 第 1 组：宇宙与地球起源 ---
            { img: './images/1.png', title: '大爆炸', quote: '宇宙由这一刻诞生，你的征程也由此开始。' },
            { img: './images/2.png', title: '太阳系', quote: '太阳系正在慢慢形成，万事开头难。' },
            { img: './images/3.png', title: '地球形成', quote: '孕育生命的摇篮，似乎有灵感涌上心头？' },
            { img: './images/4.png', title: '太古代', quote: '第一个生命诞生了，是否得到了某种启发呢？' },
            { img: './images/5.png', title: '震旦纪', quote: '进化是最伟大的馈赠，在不知不觉中，你正在感受进步。' },
            { img: './images/6.png', title: '寒武纪', quote: '鱼类最活跃的时期，鱼儿水中游，时光一去不回头。' },
            
            // --- 第 2 组：古生物演化 ---
            { img: './images/7.png', title: '奥陶纪', quote: '大陆板块形成，更大的挑战即将来临。' },
            { img: './images/8.png', title: '泥盆纪', quote: '陆地的感觉好吗？请抓紧每一分钟。' },
            { img: './images/9.png', title: '石炭纪', quote: '火山开始喷发，大型爬行动物诞生了，是否有所收获了？' },
            { img: './images/10.png', title: '三叠纪', quote: '山峰丛林开始形成，注意静心。' },
            { img: './images/11.png', title: '侏罗纪', quote: '恐龙横行的年代，保持专注，克服难关。' },
            { img: './images/12.jpg', title: '白垩纪', quote: '恐龙灭绝，现在可以告一段落了。' },

            // --- 第 3 组：人类文明发展 ---
            { img: './images/13.png', title: '古代', quote: '人类的祖先在这篇大陆上开疆辟土，学习有时候需要互相帮助。' },
            { img: './images/14.png', title: '部落', quote: '听说印第安人始终保持着这样的生活方式，今天的学习到这里也可以结束了。' },
            { img: './images/15.png', title: '村庄', quote: '人类不再到处游荡，有了自己固定的“家”，记得回忆和巩固自己今天的学习。' },
            { img: './images/16.png', title: '人群', quote: '人多力量大？前提是要有着共同的目标。' },
            { img: './images/17.png', title: '近代', quote: '王国，朝代逐渐形成，注意归纳你所学的知识。' },
            { img: './images/18.png', title: '现代', quote: '我们所生活的年代，注意劳逸结合。' },

            // --- 第 4 组：未来与终结 ---
            { img: './images/19.png', title: '城市', quote: '繁荣时期，去做做别的事情吧。' },
            { img: './images/20.png', title: '未来城市', quote: '人类科技的巅峰，每天的知识获取量是有限的。' },
            { img: './images/21.png', title: '核爆炸', quote: '物极必反，人类如此，学习也是如此。' },
            { img: './images/22.png', title: '地球毁灭', quote: '世界的尽头，它必将发生。过度的学习，会影响短期记忆。' },
            { img: './images/23.png', title: '太阳毁灭', quote: '生命迹象消失，进入效率低下期。' },
            { img: './images/24.png', title: '宇宙毁灭', quote: '生命迹象消失，进入效率低下期。' }
        ];

        // ================= 全局变量 =================
// ================= 全局变量 =================
        let totalDurationMinutes = 60; // 默认 60 分钟
        
        let isRunning = false;
        let sessionStartTimeObj = null; // 记录具体的开始日期时间对象
        let textInterval = null;       // 文字轮播定时器
        let currentResIndex = 0;       // 当前背景/文案索引
// 全局动画定时器 ID 存储池
let animTimeout1 = null;
let animTimeout2 = null;
let animTimeout3 = null;
let breatheStartTimeout = null; // 用于10秒后启动呼吸的延时
let dragDebounceTimer = null;   // 用于判断滑块何时停止
        // --- 新增：高精度计时与动画变量 ---
        let startTime = 0;             // 本次开始的时间戳
        let elapsedMs = 0;             // 暂停前积累的毫秒数
        let animationFrameId = null;   // 动画帧 ID (替代 timerInterval)
        let lastCycleIndex = 0;        // 记录当前是第几圈
        
        // --- 旧变量 (已废弃，已删除) ---
        // let timerSeconds = 0; 
        // let timerInterval = null;

        // ================= DOM 元素 =================
        const setupScreen = document.getElementById('setup-screen');
        const timerScreen = document.getElementById('timer-screen');
        
        // Picker 相关
        const pickerModal = document.getElementById('picker-modal');
        const modalOverlay = document.getElementById('modal-overlay');
        const colHour = document.getElementById('col-hour');
        const colMinute = document.getElementById('col-minute');
        const displayHours = document.getElementById('display-hours');
        const endTimeHint = document.getElementById('end-time-hint');

        // Timer 相关
        const timerDisplay = document.getElementById('timer-display');
        const progressRing = document.getElementById('progress-ring');
        const taskNameInput = document.getElementById('task-input');
        const timerTaskName = document.getElementById('timer-task-name');
        const bgLayer = document.getElementById('bg-layer');
        const alternatingText = document.getElementById('alternating-text');
        const pauseBtn = document.getElementById('pause-btn');

        // SVG 设置
        const radius = 140;
        const circumference = 2 * Math.PI * radius;
        progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
        progressRing.style.strokeDashoffset = circumference;

        // ================= 1. Picker 逻辑 (初始化 & 交互) =================
        
        const itemHeight = 44; // 与 CSS 保持一致

        // === 新增：通用的鼠标拖拽滚动函数 ===
        function enableDragScroll(container) {
            let isDown = false;
            let startY;
            let scrollTop;

            container.addEventListener('mousedown', (e) => {
                isDown = true;
                startY = e.pageY;
                scrollTop = container.scrollTop;
                // 拖拽开始时，暂时关闭 CSS 的自动吸附，否则会卡顿
                container.style.scrollSnapType = 'none';
            });

            const stopDrag = () => {
                if (!isDown) return;
                isDown = false;
                // 拖拽结束，恢复 CSS 吸附，让它自动回弹对齐
                container.style.scrollSnapType = 'y mandatory';
            };

            container.addEventListener('mouseleave', stopDrag);
            container.addEventListener('mouseup', stopDrag);

            container.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault(); // 防止默认的选择行为
                const y = e.pageY;
                const walk = (y - startY) * 1.5; // * 1.5 是为了让拖拽稍微快一点，手感更好
                container.scrollTop = scrollTop - walk;
            });
        }

        function initPicker() {
            // 生成小时 (0-12)
            let hHtml = '<div class="picker-placeholder"></div>';
            for(let i=0; i<=12; i++) hHtml += `<div class="picker-item" data-v="${i}">${i}</div>`;
            hHtml += '<div class="picker-placeholder"></div>';
            document.getElementById('hour-content').innerHTML = hHtml;

            // 生成分钟 (0-59)
            let mHtml = '<div class="picker-placeholder"></div>';
            for(let i=0; i<60; i++) mHtml += `<div class="picker-item" data-v="${i}">${i.toString().padStart(2,'0')}</div>`;
            mHtml += '<div class="picker-placeholder"></div>';
            document.getElementById('minute-content').innerHTML = mHtml;

         // 在 initPicker 函数底部，找到 setTimeout 部分，改为：
        setTimeout(() => {
            // 滚轮还是可以默认停在 1 小时 0 分钟的位置方便用户选
            colHour.scrollTop = 1 * itemHeight;
            colMinute.scrollTop = 0 * itemHeight;
            updateHighlight(colHour);
            updateHighlight(colMinute);
            // 注意：这里不再调用 calculateEndTime，因为初始状态是“未设置”
        }, 100);

            // 绑定滚动高亮事件
            colHour.addEventListener('scroll', () => updateHighlight(colHour));
            colMinute.addEventListener('scroll', () => updateHighlight(colMinute));

            enableDragScroll(colHour);
            enableDragScroll(colMinute);
        }

        function updateHighlight(container) {
            let index = Math.round(container.scrollTop / itemHeight);
            let items = container.querySelectorAll('.picker-item');
            items.forEach((item, i) => {
                if (i === index) {
                    item.style.color = '#333';
                    item.style.fontWeight = 'bold';
                    item.style.transform = 'scale(1.1)';
                } else {
                    item.style.color = '#bbb';
                    item.style.fontWeight = 'normal';
                    item.style.transform = 'scale(1)';
                }
            });
        }

        function getPickerValue() {
            let h = Math.round(colHour.scrollTop / itemHeight);
            let m = Math.round(colMinute.scrollTop / itemHeight);
            return { h, m };
        }

        // 打开弹窗
        function openPicker() {
            modalOverlay.classList.add('open');
            pickerModal.classList.add('open');
        }

        // 关闭弹窗
        function closePicker() {
            modalOverlay.classList.remove('open');
            pickerModal.classList.remove('open');
        }

        // 替换整个 confirmPicker 函数
        function confirmPicker() {
            const { h, m } = getPickerValue();
            const totalMins = h * 60 + m;

            if (totalMins === 0) {
                alert("请至少设置 1 分钟");
                return;
            }

            totalDurationMinutes = totalMins;
            
            // 1. 更新右侧数值显示
            const displayVal = (totalMins / 60).toFixed(1);
            const displayEl = document.getElementById('display-hours');
            const unitEl = document.getElementById('display-unit');
            
            displayEl.innerText = displayVal; // 显示数字
            unitEl.style.display = 'inline';  // 显示“小时”单位

            // 删除或注释掉之前给父容器加线的代码：
            // document.querySelector('.time-value-wrapper').style.borderBottom = '2px solid #2196F3';

            // 改为：给数字元素本身加线，并加一点点底部内边距让线和字不挨太近
            displayEl.style.borderBottom = '2px solid #2196F3';
            displayEl.style.paddingBottom = '4px'; 
            // 2. 更新左侧提示文字颜色和内容
            const hintEl = document.getElementById('end-time-hint');
            hintEl.style.color = '#dba859'; // 变成金/橙色
            
            calculateEndTime(totalMins); // 计算并显示结束时间

            closePicker();
        }

        function calculateEndTime(minutes) {
            const now = new Date();
            const end = new Date(now.getTime() + minutes * 60000);
            const endStr = `${end.getHours().toString().padStart(2,'0')}:${end.getMinutes().toString().padStart(2,'0')}`;
            endTimeHint.innerText = `${endStr} 会暂停且提醒结束计时`;
        }

        // ================= 2. 计时器逻辑 =================

// 1. 开始专注
function startFocus() {
            // 保存历史记录
            if(typeof saveTaskToHistory === 'function') saveTaskToHistory(taskNameInput.value);

            if (totalDurationMinutes <= 0) return alert('请先设置时长');
            
            // 切换界面
            setupScreen.classList.remove('active');
            timerScreen.classList.add('active');
            
            // 获取容器
            const timerContent = document.querySelector('.timer-content');
            
            // 进入初始模式
            timerContent.classList.add('initial-mode');
            
            // 确保没有残留的样式，清空 transform
            timerContent.style.transform = ''; 
            timerContent.classList.remove('rotate-out');

            // 初始化文字
            const userTask = taskNameInput.value || '专注时刻';
            timerTaskName.innerText = userTask; 
            
            // 底部名言先隐藏
            alternatingText.classList.add('hidden'); 
            
            // 重置状态
            elapsedMs = 0; 
            lastCycleIndex = 0;
            updateResource(0, true); 
            
            // 立即开始
            startTimerLogic();
        }
// 在 startFocus 函数内部，startTimerLogic() 之前添加：
sessionStartTimeObj = new Date(); // 记录当前真实时间
        // 2. 核心计时逻辑 (改为 requestAnimationFrame)
function startTimerLogic() {
    if (isRunning) return;
    isRunning = true;
    pauseBtn.innerText = "暂停";

    startTime = performance.now();

    const loop = () => {
        const now = performance.now();
        const currentSessionMs = now - startTime; 
        const totalCurrentMs = elapsedMs + currentSessionMs;

        const totalSeconds = totalCurrentMs / 1000;

        // 更新界面
        updateTimerUI(totalCurrentMs);
        
        // 【新增】开发者模式：滑块跟随自动更新
        if (isDevMode && devSlider) {
            devSlider.value = Math.floor(totalSeconds);
        }

        // 检查切图逻辑 (每20分钟 = 1200秒)
        const currentCycle = Math.floor(totalSeconds / 1200);
        if (currentCycle > lastCycleIndex) {
            lastCycleIndex = currentCycle;
            if(typeof currentResIndex !== 'undefined') {
                currentResIndex++;
                updateResource(currentResIndex);
            }
        }

        // 检查结束
        if (totalSeconds >= totalDurationMinutes * 60) {
            elapsedMs = totalDurationMinutes * 60 * 1000; 
            updateTimerUI(elapsedMs); 
            
            // 【新增这一行】自然结束时，先关掉运行状态。
            // 这样进入 showSummaryModal() 时，就不会重复累加时间了。
            isRunning = false; 

            finishTimer();
            return; 
        }

        if (isRunning) {
            animationFrameId = requestAnimationFrame(loop);
        }
    };

    animationFrameId = requestAnimationFrame(loop);
    if(typeof startTextAnim === 'function') startTextAnim();
}

        // 3. 界面更新逻辑 (接收毫秒参数)
        function updateTimerUI(currentMs) {
            // --- A. 更新时间文字 (向下取整显示) ---
            const totalSecondsInt = Math.floor(currentMs / 1000);
            const h = Math.floor(totalSecondsInt / 3600);
            const m = Math.floor((totalSecondsInt % 3600) / 60);
            const s = totalSecondsInt % 60;
            timerDisplay.innerText = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

            // --- B. 更新进度条 (使用毫秒计算，丝滑无停顿) ---
            const cycleTimeMs = 1200 * 1000; // 20分钟 = 1200000毫秒
            const totalTargetMs = totalDurationMinutes * 60 * 1000;

            // 1. 当前周期的起始毫秒数
            let currentCycleStartMs = Math.floor(currentMs / cycleTimeMs) * cycleTimeMs;
            
            // 2. 计算这一圈的总时长 (毫秒)
            let remainingMsFromCycleStart = totalTargetMs - currentCycleStartMs;
            let currentRingDurationMs;

            if (remainingMsFromCycleStart < cycleTimeMs) {
                // 最后一段不足20分钟
                currentRingDurationMs = remainingMsFromCycleStart;
            } else {
                // 标准20分钟
                currentRingDurationMs = cycleTimeMs;
            }

            // 3. 当前这一圈跑了多少毫秒
            let timeInThisCycleMs = currentMs - currentCycleStartMs;

            // 4. 计算比例
            if (currentRingDurationMs <= 0) currentRingDurationMs = 1;
            let percent = timeInThisCycleMs / currentRingDurationMs;
            if (percent > 1) percent = 1; // 封顶

            // 5. 应用样式
            const offset = circumference - (percent * circumference);
            progressRing.style.strokeDashoffset = offset;
        }

        // 4. 暂停/继续
        function togglePause() {
            if (isRunning) {
                // === 暂停 ===
                isRunning = false;
                pauseBtn.innerText = "继续";
                
                // 停止动画帧
                cancelAnimationFrame(animationFrameId);
                clearInterval(textInterval);

                // 关键：把这段时间跑的毫秒数累加保存
                const now = performance.now();
                elapsedMs += (now - startTime);

            } else {
                // === 继续 ===
                startTimerLogic(); // 重新开始循环，startTime 会被重置为当前
            }
        }

function stopTimer() {
    // 1. 停止运行标志
    isRunning = false;
    
    // 2. 清除各种定时器
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (textInterval) clearInterval(textInterval);
    
    // 3. 【关键】切换页面 UI：隐藏计时页，显示设置页
    timerScreen.classList.remove('active'); 
    setupScreen.classList.add('active');    
    
    // 4. 重置按钮文字
    if (pauseBtn) pauseBtn.innerText = "暂停";

    // 5. 如果开启了开发者模式，顺便关闭它
    if (typeof isDevMode !== 'undefined' && isDevMode) {
        exitDevMode();
    }
}

        function finishTimer() {
            stopTimer();
            alert('恭喜，专注任务完成！');
        }

        // ================= 3. 背景与文字切换 =================

// 替换 updateResource 函数
        function updateResource(idx, isFirstLoad = false) {
            const data = resources[idx % resources.length];
            
            // 1. 切换背景
            bgLayer.style.backgroundImage = `url('${data.img}')`;
            
            // 2. 如果不是第一次加载（中间自动切图），按正常逻辑淡入淡出
            if (!isFirstLoad) {
                timerTaskName.classList.add('hidden');
                alternatingText.classList.add('hidden');
                setTimeout(() => {
                    timerTaskName.innerText = data.title;
                    alternatingText.innerText = data.quote;
                    timerTaskName.classList.remove('hidden');
                    alternatingText.classList.remove('hidden');
                }, 1000);
            } 
            // 如果是 isFirstLoad (刚开始)，文字由 startFocus 和 startTextAnim 控制，这里不操作
        }

// 替换原有的 startTextAnim
function startTextAnim() {
    resetAllTextAnims(); // 先清空旧的

    const data = resources[currentResIndex % resources.length];
    const timerContent = document.querySelector('.timer-content');

    // === 阶段1: 翻转动画 (0s - 2s) ===
    animTimeout1 = setTimeout(() => {
        timerContent.style.transition = 'transform 0.5s linear';
        timerContent.classList.add('rotate-out');
        alternatingText.classList.add('hidden');
        
        animTimeout2 = setTimeout(() => {
            timerContent.style.opacity = '0';
            timerContent.classList.remove('initial-mode');
            
            timerTaskName.innerText = data.title;
            alternatingText.innerText = data.quote;
            
            timerContent.style.transition = 'none';
            timerContent.style.transform = 'perspective(600px) rotateY(-90deg)';
            timerContent.classList.remove('rotate-out');
            void timerContent.offsetWidth; 

            requestAnimationFrame(() => {
                timerContent.style.opacity = '1';
                timerContent.style.transition = 'transform 0.5s linear';
                timerContent.style.transform = 'perspective(600px) rotateY(0deg)';
                alternatingText.classList.remove('hidden');
                
                // 恢复过渡样式
                setTimeout(() => {
                    timerTaskName.style.transition = 'opacity 1.5s ease-in-out, font-size 0.1s';
                    alternatingText.style.transition = 'opacity 1.5s ease-in-out';
                }, 500);
            });
            
        }, 500); 
    }, 1500);

    // === 阶段2: 10秒后启动呼吸 ===
    // 这里不再用写死的 setTimeout，而是存起来
    breatheStartTimeout = setTimeout(() => {
        if(isRunning) {
            startBreathingOnly();
        }
    }, 10000);
}
        // ================= 初始化 =================
        initPicker();

        // ================= 历史记录逻辑 =================

        const taskInput = document.getElementById('task-input');
        const historyDropdown = document.getElementById('history-dropdown');

        // 从本地存储获取历史数据 { "任务名": 次数 }
        function getHistory() {
            return JSON.parse(localStorage.getItem('taskHistory')) || {};
        }

        // 修改：渲染下拉菜单
function showHistoryDropdown() {
    const history = getHistory(); // 获取 {"背单词": 5, "看书": 2}
    const list = [];

    // 筛选：逻辑保持不变 (此处代码是 >=2，如果你想改成 >3，请把下面的 2 改成 4)
    for (let [name, count] of Object.entries(history)) {
        if (count >= 2) { 
            list.push(name);
        }
    }

    if (list.length === 0) {
        historyDropdown.style.display = 'none';
        return;
    }

    // 生成 HTML：左右分栏结构
    let html = '';
    list.forEach(name => {
        // 注意：onmousedown 比 onclick 更早触发，防止 blur 事件先执行导致无法点击
        html += `
            <div class="history-item">
                <!-- 左边：点击填入文字 -->
                <div class="history-item-text" onmousedown="selectHistory('${name}')">${name}</div>
                <!-- 右边：点击删除 (传入 event 用于阻止冒泡) -->
                <div class="history-item-del" onmousedown="deleteTaskSuggestion('${name}', event)">×</div>
            </div>
        `;
    });
    historyDropdown.innerHTML = html;
    historyDropdown.style.display = 'block';
}

// 新增：删除下拉建议 (无确认)
function deleteTaskSuggestion(name, event) {
    // 阻止事件冒泡，防止触发 input 的 blur 或其他点击事件
    if (event) event.stopPropagation();

    const history = getHistory();
    
    // 删除该属性
    delete history[name];
    
    // 保存回本地
    localStorage.setItem('taskHistory', JSON.stringify(history));
    
    // 重新渲染下拉菜单 (如果删完空了会自动隐藏)
    showHistoryDropdown();
    
    // 保持输入框焦点，防止删除后菜单消失
    taskInput.focus(); 
}

        // 选择历史记录
        function selectHistory(name) {
            taskInput.value = name;
            historyDropdown.style.display = 'none';
        }

        // 保存历史记录 (在开始学习时调用)
        function saveTaskToHistory(taskName) {
            if (!taskName.trim()) return; // 空任务不保存
            
            const history = getHistory();
            // 计数 + 1
            if (history[taskName]) {
                history[taskName]++;
            } else {
                history[taskName] = 1;
            }
            localStorage.setItem('taskHistory', JSON.stringify(history));
        }

        // --- 事件监听 ---

        // 1. 输入框获得焦点时：尝试显示历史记录
        taskInput.addEventListener('focus', showHistoryDropdown);

        // 2. 输入框失去焦点时：延迟隐藏（为了让点击事件能先触发）
        taskInput.addEventListener('blur', () => {
            setTimeout(() => {
                historyDropdown.style.display = 'none';
            }, 200);
        });

        // ================= 结束控制逻辑 =================

 // 1. 拦截“结束”按钮
function confirmEnd() {
    if (confirm("确定结束并保存记录吗？")) {
        showSummaryModal(); // 以前是直接 stopTimer()，现在改为显示弹窗
    }
}

// 2. 拦截自动倒计时结束
function finishTimer() {
    // 播放提示音或震动等...
    alert('专注任务完成！请填写心得。'); // 可选
    showSummaryModal();
}

// 3. 显示总结弹窗逻辑
// 3. 显示总结弹窗逻辑 (已修复时长丢失 Bug)
function showSummaryModal() {
    // 【关键修复开始】：如果当前正在运行，必须把“最后这一段”时间加进去
    if (isRunning) {
        const now = performance.now();
        elapsedMs += (now - startTime);
        isRunning = false; // 结算完毕后，再标记为停止
    }
    // 【关键修复结束】

    // 停止动画帧和轮播
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    if (textInterval) clearInterval(textInterval);

    // 计算最终时长字符串
    const finalMs = elapsedMs; // 此时 elapsedMs 已经是完整的总耗时了
    const totalSec = Math.floor(finalMs / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;
    const timeStr = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

    // 填充弹窗数据
    document.getElementById('summary-duration').innerText = timeStr;
    document.getElementById('summary-note').value = ''; // 清空备注
    
    // 显示弹窗
    document.getElementById('summary-overlay').classList.add('open');
    document.getElementById('summary-modal').classList.add('active');
}

function closeSummary(isSave) {
    // 隐藏弹窗
    document.getElementById('summary-overlay').classList.remove('open');
    document.getElementById('summary-modal').classList.remove('active');
    
    // 如果用户点击的是“不保存”按钮(isSave为false)，
    // 我们也要手动调用 stopTimer 让它回主页，否则就卡在黑屏了
    if (!isSave) {
        stopTimer(); 
    }
}

        // ================= 全屏控制逻辑 =================

        // 监听全局键盘事件
        document.addEventListener('keydown', (e) => {
            // 检测组合键：Shift + Enter
            if (e.shiftKey && e.key === 'Enter') {
                e.preventDefault(); // 防止可能产生的默认换行等行为
                enterFullScreen();
            }
        });

        function enterFullScreen() {
            // 获取文档根元素 (<html>)
            const elem = document.documentElement;

            // 检查当前是否已经是全屏
            if (!document.fullscreenElement) {
                // 兼容不同浏览器的 API
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } else {
                // 如果用户想用 Shift+Enter 退出全屏也可以（可选）
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
        
        // 监听全屏变化事件（可选：用于调试或后续扩展 UI 变化）
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                console.log("已进入全屏沉浸模式");
            } else {
                console.log("已退出全屏");
            }
        });

        // ================= 开发者模式逻辑 =================

const devContainer = document.getElementById('dev-timeline-container');
const devSlider = document.getElementById('dev-slider');
let isDevMode = false;

// 1. 监听输入框的“暗号”
taskInput.addEventListener('keydown', (e) => {
    // 检测是否按下回车
    if (e.key === 'Enter') {
        const val = taskInput.value.trim().toLowerCase();
        
        if (val === 'water') {
            e.preventDefault(); // 阻止默认回车行为
            activateDevMode();  // 激活开发者模式
        }
    }
});

// 2. 激活开发者模式函数
function activateDevMode() {
    isDevMode = true;
    
    // 强制设置时长为 8 小时 (480分钟)
    totalDurationMinutes = 480; 
    
    // 显示时间轴
    devContainer.style.display = 'block';
    
    // 自动填充一个任务名
    if(!taskInput.value || taskInput.value === 'water') {
        taskInput.value = "Developer Testing"; 
    }

    // 调用原本的开始函数
    startFocus();
    
    // 提示
    console.log("开发者模式已激活：时间轴已开启");
}

// 3. 时间轴拖动监听 (修改版：无缝穿梭，不暂停)
// 开发者模式：滑块监听 (最终优化版)
devSlider.addEventListener('input', (e) => {
    if (!isDevMode) return;

    // 1. 【关键】只要手一碰滑块，马上杀掉所有动画，保持文字常亮
    resetAllTextAnims();
    // 也要清除之前的防抖计时器
    if (dragDebounceTimer) clearTimeout(dragDebounceTimer);

    // 2. 更新时间逻辑 (保持之前的无缝穿梭逻辑)
    const sliderSeconds = parseInt(e.target.value);
    const sliderMs = sliderSeconds * 1000;

    if (isRunning) {
        startTime = performance.now();
        elapsedMs = sliderMs;
    } else {
        elapsedMs = sliderMs;
    }
    updateTimerUI(sliderMs);

    // 3. 资源切换逻辑
    const correctCycleIndex = Math.floor(sliderSeconds / 1200);
    if (correctCycleIndex !== currentResIndex) {
        currentResIndex = correctCycleIndex;
        updateResource(currentResIndex, true); 
        
        // 强制刷新文字内容
        const data = resources[currentResIndex % resources.length];
        timerTaskName.innerText = data.title;
        alternatingText.innerText = data.quote;
    }

    // 4. 【关键】防抖重启逻辑
    // 当用户停止拖动 1000ms (1秒) 后，判断是否需要恢复呼吸
    dragDebounceTimer = setTimeout(() => {
        // 如果当前时间已经超过 10秒 (10000ms)，则启动呼吸循环
        // 如果小于 10秒，我们就保持常亮，不启动呼吸，直到时间自然流逝到10秒
        if (sliderMs >= 10000 && isRunning) {
            console.log("滑块停止，且时间>10s，恢复呼吸动画");
            startBreathingOnly();
        } else if (isRunning) {
            // 如果时间 < 10s，我们需要补一个 timer，让它在到达 10s 时启动
            const remaining = 10000 - sliderMs;
            console.log(`滑块停止，时间<10s，将在 ${remaining}ms 后启动呼吸`);
            breatheStartTimeout = setTimeout(() => {
                if(isRunning) startBreathingOnly();
            }, remaining);
        }
    }, 1000);
});

    // 在 activateDevMode 函数下面添加这个函数

function exitDevMode() {
    // 1. 关闭开发者模式标识
    isDevMode = false;
    
    // 2. 隐藏时间轴界面
    devContainer.style.display = 'none';
    
    // 3. 恢复自动计时（如果在拖拽过程中暂停了）
    // 如果当前是暂停状态，我们保持暂停；
    // 如果本来就在运行，或者我们想让它自动继续，可以做个判断。
    // 这里为了体验流畅，如果你关闭了调试条，我们默认帮你恢复“运行”状态（除非你手动点了暂停）
    if (!isRunning && pauseBtn.innerText === "继续") {
        // 如果是暂停状态，什么都不做，等待用户点继续
    } else if (!isRunning) {
        // 如果是因为拖拽导致的临时暂停，恢复运行
        togglePause(); 
    }

    console.log("开发者模式已关闭，回归正常时间流");
}

// ================= 历史记录与导出逻辑 =================

// 1. 保存并退出 (Save & Exit)
// 1. 保存并退出 (Save & Exit)
function saveAndExit() {
    // 1. 获取输入内容
    const note = document.getElementById('summary-note').value;
    
    // 【关键修改】：
    // 之前是抓取 #timer-task-name (它会被动画改成“大爆炸”等)
    // 现在改为抓取 #task-input (用户最初在设置页填写的真实任务)
    const taskName = document.getElementById('task-input').value.trim() || '专注时刻';
    
    // 2. 计算时长
    const totalSec = Math.floor(elapsedMs / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;
    const durationStr = `${h}小时${m}分${s}秒`;

    // 3. 格式化开始时间
    let startTimeStr = "未知时间";
    if (sessionStartTimeObj && sessionStartTimeObj.toLocaleString) {
        startTimeStr = sessionStartTimeObj.toLocaleString();
    }

    // 4. 构建数据对象
    const record = {
        id: Date.now(),
        task: taskName, // 现在这里保存的就是正确的任务名了
        startTime: startTimeStr,
        duration: durationStr,
        note: note
    };

    // 5. 保存到 LocalStorage (immersiveHistory)
    let historyList = JSON.parse(localStorage.getItem('immersiveHistory')) || [];
    historyList.unshift(record);
    localStorage.setItem('immersiveHistory', JSON.stringify(historyList));

    // 6. 更新简易下拉历史 (taskHistory)
    // 注意：startFocus 时已经记过一次了，这里如果不想重复计数，可以注释掉下面这几行
    if (typeof saveTaskToHistory === 'function') {
        saveTaskToHistory(taskName);
    }

    // 7. 关闭弹窗
    closeSummary(true);

    // 8. 调用停止函数以返回主页
    stopTimer(); 
}

// 2. 打开历史记录列表
// 修改：打开历史记录列表 (增加了 index 参数用于删除定位)
function openHistoryModal() {
    const list = JSON.parse(localStorage.getItem('immersiveHistory')) || [];
    const container = document.getElementById('history-list-content');
    
    if (list.length === 0) {
        container.innerHTML = '<div class="empty-tip">暂无学习记录</div>';
    } else {
        let html = '';
        // 遍历时加上 index，方便删除
        list.forEach((item, index) => {
            html += `
                <div class="history-row">
                    <!-- 删除按钮：传入 index -->
                    <div class="btn-delete-record" onclick="deleteHistoryItem(${index})" title="删除此条">×</div>
                    
                    <div class="history-row-top">
                        <span>${item.task}</span>
                        <span>${item.duration}</span>
                    </div>
                    <div class="history-row-mid">
                        <span>${item.startTime}</span>
                    </div>
                    ${item.note ? `<div class="history-note">📝 ${item.note}</div>` : ''}
                </div>
            `;
        });
        container.innerHTML = html;
    }

    document.getElementById('history-overlay').classList.add('open');
    document.getElementById('history-modal').classList.add('active');
}

// 新增：删除单条历史记录 (无确认)
function deleteHistoryItem(index) {
    let list = JSON.parse(localStorage.getItem('immersiveHistory')) || [];
    
    // 删除对应索引的元素
    list.splice(index, 1);
    
    // 保存回本地
    localStorage.setItem('immersiveHistory', JSON.stringify(list));
    
    // 立即重新渲染列表
    openHistoryModal();
}

function closeHistoryModal() {
    document.getElementById('history-overlay').classList.remove('open');
    document.getElementById('history-modal').classList.remove('active');
}

// 3. 导出为 Excel (CSV 格式)
function exportToExcel() {
    const list = JSON.parse(localStorage.getItem('immersiveHistory')) || [];
    if (list.length === 0) return alert('暂无数据可导出');

    // CSV 表头
    let csvContent = "任务名称,开始时间,专注时长,心得备注\n";

    list.forEach(item => {
        // 处理备注中的换行符和逗号，防止 CSV 格式错乱
        let safeNote = item.note ? item.note.replace(/,/g, '，').replace(/\n/g, ' ') : '';
        csvContent += `${item.task},${item.startTime},${item.duration},"${safeNote}"\n`;
    });

    // 创建 Blob 对象 (加上 \uFEFF 是为了让 Excel 正确识别中文 UTF-8)
    const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' });
    
    // 创建下载链接
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    
    // 生成文件名：专注记录_20231027.csv
    const date = new Date();
    const dateStr = `${date.getFullYear()}${date.getMonth()+1}${date.getDate()}`;
    
    link.setAttribute("href", url);
    link.setAttribute("download", `专注记录_${dateStr}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// A. 强力清除所有文字动画 (让文字保持静止可见)
function resetAllTextAnims() {
    // 1. 清除所有定时器
    if (textInterval) clearInterval(textInterval);
    if (animTimeout1) clearTimeout(animTimeout1);
    if (animTimeout2) clearTimeout(animTimeout2);
    if (animTimeout3) clearTimeout(animTimeout3);
    if (breatheStartTimeout) clearTimeout(breatheStartTimeout);

    // 2. 强制显示文字
    const timerContent = document.querySelector('.timer-content');
    if (timerContent) {
        timerContent.style.opacity = '1';
        timerContent.classList.remove('rotate-out');
        // 移除翻转时的 transition，防止拖动时还有残留的旋转动效
        timerContent.style.transition = ''; 
    }
    
    // 3. 移除 hidden 类，确保可见
    timerTaskName.classList.remove('hidden');
    alternatingText.classList.remove('hidden');
}

// B. 单独启动呼吸循环 (不含翻转)
function startBreathingOnly() {
    // 先清除可能存在的循环
    if (textInterval) clearInterval(textInterval);

    const runLoop = () => {
        if (!isRunning) return;
        // 隐
        timerTaskName.classList.add('hidden');
        alternatingText.classList.add('hidden');
        
        // 10秒后显
        animTimeout3 = setTimeout(() => {
            if(isRunning) {
                timerTaskName.classList.remove('hidden');
                alternatingText.classList.remove('hidden');
            }
        }, 10000);
    };

    // 立即执行一次
    runLoop();
    // 之后每 20秒循环
    textInterval = setInterval(runLoop, 20000);
}
    </script>
</body>
</html>